%\documentclass[11pt]{article}
\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\powname}{Autolykos\xspace}
\newcommand{\mixname}{ErgoMix\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}

\newcommand{\primname}{Commitment of Work\xspace}
\newcommand{\prim}{CoW\xspace}


\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}


\title{An Overview of \powname, the Ergo PoW}
\author{Developers}
\institute{Ergo Platform}
\maketitle

\begin{abstract}
	In this article, we give an overview of \powname, the Proof-of-Work (PoW) algorithm used in Ergo. We briefly discuss mining and various unique aspects of the protocol, such as {\em pool resistance} (preventing mining coalitions among mutually distrusting parties). We also discuss ways to ``break'' this pool-resistance and create mining pools. 
	 
\end{abstract}

\section{Introduction}

Ergo\footnote{\url{https://ergoplatform.org}} is a smart contract platform running on its own blockchain. It provides a high-level language called \langname used for writing contracts featuring Ethereum-like functionality but more closer to Bitcoin in the underlying design. For instance, it is based on short-lived objects (called UTXOs in Bitcoin and {\em boxes} in Ergo) instead of long-lived accounts to store data and code. It also has some features different from both Bitcoin and Ethereum relating to scalability and long-term survivability. For instance, it has a {\em storage-rent} component, so that boxes must pay rent to continue staying on the blockchain. Secondly, it allows running a fully verifying node on low-power devices using an idea called {\em Non-interactive Proofs-of-proofs of Work}~\cite{kiayias2017non}. Finally, it uses a PoW algorithm called \powname~\cite{autolykos} that discourages mining-pool formation, which we informally term {\em pool-resistance}. This article gives an overview of \powname. 

We assume that the reader is familiar with the basic structure of Bitcoin transactions and knows the terms such as UTXOs, inputs and outputs. Additionally, the reader is assumed to have some knowledge of how Bitcoin outputs are protected (locked) by scripts and how the spender unlocks them. 
Before getting into \powname, it is useful to understand the design of Bitcoin's PoW. 


\section{Bitcoin PoW}
In Bitcoin, a miner collects a number of unconfirmed transactions and concatenates them using a Merkle tree. All nodes of this tree except the leaves are 32 byte hashes computed from its children. The root of this tree, denoted $t$ here, is stored in another structure called the {\em block header}, which also includes the hash of the previous block's header $h$ and a random string $n$ called the nonce. We use the term $m$ to denote the concatenation of Merkle root and the hash of the previous block. 
That is, $m = t\|h$ and the header is of the form $m\|n$. 

The solution is also determined by another parameter $b < 2^{256}$, denoting the `difficulty'. Let $F$ be a hash function taking as input an arbitrary sized array of bits and outputting an array of 256 bits (32 bytes). The output of $F$ can be considered a number between 0 and $2^{256}-1$. The header $m\|n$ is considered a valid solution if $F(m\|n) \leq b$. 

A miner repeatedly tries different values of $n$ (possibly changing $m$ as well by including new transactions in between tries) until a solution is found. Since the output of $F$ can be thought of as distributed uniformly in the output space, the probability of finding a solution in each try is $\tau = b/2^{256}$. All proof-of-work algorithms (including that of Ergo) follow this basic idea of restricting the output to be less than some $b$. It is worth noting that, for Bitcoin, as of this writing (July 2019), $b\approx 2^{181}$, and so $\tau \approx 2^{-75}\approx 10^{-22.6}\approx 0.0000000000000000000000257$.

\section{Mining Pools}

Bitcoin and all other cryptocurrencies allow mining pools, which roughly work as follows. The pool distributes work, based on a some $m$ that it decides. Each miner tries to find a solution for the given $m$ and any solution found is sent to the network. 
A miner actually tries to find a {\em share}, which is like a solution but with reduced difficulty. Some of the shares may also be solutions for the actual difficulty, which become valid blocks. A miner gets paid by the number of shares submitted.
The key observation with pools is that miners do work for some other entity who then distributes the rewards back to the workers.
We define three levels of centralization in pools. 

\begin{enumerate}
	\item {\em Level 1 (No decentralization):} The pool operator is defines both $m$ and the reward address. Thus, a pool operator has full control over which transactions are included (censorship) and also carries the risk of losing the rewards.
	\item {\em Level 2 (Censorship resistant):} The pool operator does not defines $m$ but collects the rewards. This is resistant to sensorship but still carries the risk of losing the rewards. This is what we will try achive for Ergo. 
	\item {\em Level 3 (Complete decentralization):} There is no pool operator and rewards are automatically given to the participants based on the shares they submitted (example P2Pool for Bitcoin and SmartPool for Ethereum).
\end{enumerate}

\section{Ergo PoW}

Ergo is derived from Bitcoin but has some major differences. The prime difference is that while in Bitcoin, the reward UTXO may be spendable by someone other than the miner finding a block, in Ergo, the reward box is spendable only by that miner. In other words, any Ergo node that finds a block also has the ability to spend those rewards. Furthermore, the converse is also true: anyone who spends the reward must necessarily have had the ability to generate that block. While this may not seem much of a difference from Bitcoin because the miner usually sends the reward to their own address, consider situations such as P2Pool~\cite{p2pool}, where the reward is sent to all the ``share-holders'' of that block. 

If we try to create a system like P2Pool or even a centralized pool based on existing models, we find that anyone having the ability to find a solution is able to steal the rewards, thereby creating a race condition for spending the reward 720 blocks later. This is done using a combinations of two approaches in Ergo:
\begin{enumerate}
	\item \textbf{\powname:} The solution contains two additional parameters: a public key $p$ (corresponding to some secret key $s$) and a signature on the message $m$ (this message is the same as in Bitcoin) that verifies with $p$. Because of this signature, secret key $s$ is necessary to generate the solution. 

	The signature consists of a pair $(d, w)$, where $d$ is an integer and $w$ is a string.
%	 (see Apendix~\ref{schnorr}). I
%	rrespective of how $w$ is selected, the value $d$ is 
	The solution is valid if $d$ has a certain number of leading zeros. 
	The complete protocol for creating and verifying the solution is called {\em \powname}~\cite{autolykos}.
	\item \textbf{Emission contract:} The reward transaction must have exactly one output storing the reward (initially 67.5 Ergs), which is protected using the script: {\em prove knowledge of secret key corresponding to public key $p$}. Because of this script, secret key $s$ is necessary to spend the reward. This is done using something called an {\em Emission Contract}, discussed in Section~\ref{emission}.
\end{enumerate} 

In a nutshell, an Ergo block header is of the form $m\|n\|p\|w\|d$ such that:
\begin{enumerate}
	\item $m, n$ serve similar purpose as in Bitcoin and $p$ is a public key.
	\item $m$ is created such that the reward is spendable only by the owner of $p$.
	\item $w$ is a random value needed for verifying the solution. 
	\item $d$ is a signature on $F(m\|n\|p\|w)$ that verifies with $p$. 
	\item $d\leq b$, where $b$ serves similar purpose as in Bitcoin. 
\end{enumerate}

Observe that given a solution, verifying it is very fast~(see~\cite{autolykos} for benchmarks). It involves 1 computation of $F$ and one signature verification. 

%Before going on to discuss the features of the above scheme, we first describe how to find a solution. 
Because of the nature of the signature scheme used~\cite{autolykos}, and in particular due to the hash function $F$, the value of $d$ is uniformly distributed in $[0..2^{256}-1]$. The only known approach to find such a $d$ is to try different values of $n$ (and possibly $w$), compute $F(m\|n\|p\|w)$, and then check if the resulting $d$ is less than $b$.
Thus, as in Bitcoin, the probability of $d$ being in the correct range is $b/2^{256}$, which is the probability of finding the right solution in one try.
  
In \powname, special care is taken to ensure that the hash function $F$ is {\em memory hard}, i.e., it requires either too much time or too much memory. It is done by constructing the hash function $F$ in a specific way to make \powname ASIC resistant~\cite{autolykos}. 
\section{Emission Box}

\label{emission}

One of the goals of Ergo was to have a {\em pool resistant} protocol, which informally means that pool formation in economically unviable.
However, \powname alone is not sufficient to obtain {\em pool-resistance}. In addition, Ergo uses an {\em emission contract} encapsulated in an {\em emission box} which has all the (finite amount of) rewards locked in. Each miner must spend this box to collect rewards. The contract inside this box has the following conditions:

\begin{enumerate}
	\item The first output of the reward transaction must be another emission box with the same script as this and with the remaining ergs after deducting the appropriate reward amount. The reward amount is specified by a formula encoded in \langname. 
	After several years when the emission box becomes empty, it will be automatically destoyed.
	\item The second output of the reward transaction must contain the entire reward and be protected by the script {\em prove knowledge of secret key corresponding to public key $p$}, where $p$ is the public key in the \powname solution.  
\end{enumerate}

Thus, any miner wishing to collect rewards from emission must store them in another box protected using the public key $p$, whose secret key is needed to generate the current solution. What this means is that anyone who has the ability to generate a solution also has the ability to collect rewards. Consequently, when the reward becomes permanent (720 blocks later), there will be a race between anyone knowing the secret key to grab the rewards. Contrast this with Bitcoin, where the reward may be sent to any address. 

The key factor that allows pooling in the Bitcoin and other blockchains is the ability to send rewards to an address independent of the block solution (to a pool address or to all the participants). In Ergo, however, this requires that any operator running a pool and wanting the participants to pay the reward to some given address $p$ must also share the corresponding secret key $s$, thereby giving the participants also the ability to spend the rewards.
We note that there are other approaches to create a pool in Ergo that do not require paying to the pools address as discussed below.

%Note that a miner may not spend the emission box and could send the fee portion of the rewards to any address of choice. 

\section{Creating an \powname Mining Pool}

We describe a simple approach to create a mining pool in Ergo. The key observation is that in a valid share, the reward need not necessarily be sent directly to the pool's address. What is actually necessary is that an amount equivalent to the reward is sent to the pool's address. This simple observation allows us to create a pool with the following rules.
\begin{enumerate}
	\item Each miner can send the reward to his own public key $p$, whose secret key only he knows.
	\item The block must also have another transaction sending the same amount as the reward to the pool address.
\end{enumerate}

A valid share is a solution to a block with the above structure. A pool operator collects such shares and any funds thus received are distributed among the miners based on the number of shares they submitted.

One drawback of the above method is that each miner must have an equivalent amount of ergs to cover the reward amount at any time, even though the reward become spendable only after 720 blocks. To overcome this, a pool may provide incentives such as allowing the miner to keep a small fraction of the reward (example for the current reward of 67.5 ergs, the pool may require only 65 ergs to be sent to it).

\bibliographystyle{unsrt}
\bibliography{main}


\end{document}